parser grammar TParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractTParser;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = TLexer;
	rewrite = true;

	//In case of trouble -shut off:
	ASTLabelType = CommonTree;
}

// Some imaginary tokens for tree rewrites
//
tokens {
    NULL;
	START;
	OUTPUT;
	HYPOTHESIS;
	HYPOTHESIS_BODY;
	HYPOTHESES;
	DESCRIPTIONS;
	DOMAINS;
	ATTRIBUTES;
	RUNS;
	CLASSES;
	CLASS_DESCRIPTION;
	RULE;
	RULE_PARAMS;
	SELECTOR;
	SELECTORS;
	SELECTOR_PARAMS;
	VALUE;
	PARAMETER;
}

// What package should the generated source exist in?
//
@header {

    package agh.aq21gui.aq21grammar;
}

//output : output_items EOF -> ^(START output_items) ;

output : output_item* EOF
 -> ^(OUTPUT output_item*) ;

output_item
 : description -> ^(DESCRIPTIONS)
 | domains -> ^(DOMAINS)
 | attributes -> ^(ATTRIBUTES)
 | runs -> ^(RUNS)
 | output_hypotheses -> ^(HYPOTHESES output_hypotheses) ;

description : DESCRIPTION OPEN any_character* CLOSE
 -> ^(NULL) ;

any_character : ID | FLOAT | DOT | SLASH | EQUAL
 -> ^(NULL) ;

attributes : ATTRIBUTES OPEN attribute* CLOSE
 -> ^(NULL) ;

attribute 
   : ID ID EPSILON EQUAL FLOAT COST EQUAL FLOAT
 -> ^(NULL) ;

domains : DOMAINS OPEN domain* CLOSE -> ^(NULL) ;

domain
   : ID ID OPEN simple_value (COMA value)* CLOSE
 -> ^(NULL)
   | ID ID simple_value (COMA value)*
 -> ^(NULL)
   ;

runs : RUNS OPEN parameter* runs_list CLOSE
 -> ^(NULL) ;

runs_list : run* ;

run : ID OPEN parameter* run_result* CLOSE
 -> ^(NULL) ;

run_result : RESULT_NAME OPEN result_parameter* CLOSE
 -> ^(NULL) ;

output_hypotheses : OUTPUT_HYPOTHESES name=ID OPEN parameter* hypothesis CLOSE
 -> $name hypothesis parameter* ;

hypothesis : class_descriptions rule*
 -> ^(HYPOTHESIS_BODY class_descriptions rule*) ;

rule : RULE_ARROW selectors
	-> ^(RULE selectors ^(NULL)) 
     | RULE_ARROW selectors rule_additional_params+
	-> ^(RULE selectors rule_additional_params+) ;

selectors : selector+
 -> ^(SELECTORS selector+) ;

selector : OPEN_SQR name=ID kind=EQUAL simple_value selector_additional_params? CLOSE_SQR 
	-> ^(SELECTOR $name $kind simple_value);

selector_additional_params : COLON simple_value (COMA simple_value)*  
	-> ^(SELECTOR_PARAMS) ;

rule_additional_params : COLON parameter (COMA parameter)* 
	-> ^(RULE_PARAMS) ;

result_parameter : ID COMA FLOAT
 -> ^(PARAMETER) ;

//parameters : parameter* -> ^(NULL) ;

parameter : ID EQUAL value
 -> ^(NULL) ;

value : simple_value
 -> ^(VALUE simple_value)
 | class_descriptions
 -> class_descriptions ;

class_descriptions : class_description+
 -> ^(CLASSES class_description+) ;

class_description : OPEN_SQR name=ID kind=EQUAL simple_value CLOSE_SQR
 -> ^(CLASS_DESCRIPTION $name $kind simple_value) ; 

simple_value : id_value=ID ->  $id_value
             | fl_value=FLOAT ->  $fl_value 
             | pe_value=PERCENT ->  $pe_value ;

// This is just a simple parser for demo purpose
//
// a  : b* EOF
//
//      -> ^(SCRIPT b*)
//   ;

// keyser
//   : KEYSER^ SOZE
//   ;

// expression
//   : addExpr (ADD^ addExpr)*
//   ;
